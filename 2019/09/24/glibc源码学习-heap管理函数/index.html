<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head><meta name="generator" content="Hexo 3.8.0">
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://yoursite.com/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://yoursite.com">
<meta name="author" content="treebacker">
<link rel="stylesheet" href="../../../../css/SimpleStyle.min.css">

<link rel="shortcut icon" href="../../../../images/favicon.png">


<title>glibc源码学习-heap管理函数 - Watch Security</title>

<meta name="keywords" content="glibc">

<meta name="description " content="">

</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="Tree">Tree</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">Treebacker</h1>
        <h3 class="cover-siteTitle">愿麦子和麦子长在一起，愿河流与河流流归一处。</h3>
        <p class="cover-siteDesc">岁月易逝，痕影难觅</p>
        <div class="cover-sns">
            
            <div class="btn btn-github">
                <a href="https://github.com/treebacker" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
            
                <li class="active">
                    <a href="/categories/tech-notes" data-name="技术">技术</a>
                </li>
            
                <li class="">
                    <a href="/categories/essays" data-name="随笔">随笔</a>
                </li>
            
                <li class="">
                    <a href="/categories/cdcitizen-of-the-sun" data-name="海子">海子</a>
                </li>
            
                <li class="">
                    <a href="/categories/others" data-name="其他">其他</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" placeholder="请输入关键字">
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '../../../../content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar">
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank">Treebacker</a>
                    <span title="最后编辑于2019-09-24">2019-09-24</span>
                </p>
                <p></p>
            </div>
            <h2 class="post-title">glibc源码学习-heap管理函数</h2>
            <div class="post-meta">
                本文总共16857个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <h4 id="heap相关结构体"><a href="#heap相关结构体" class="headerlink" title="heap相关结构体"></a>heap相关结构体</h4><ul>
<li><h5 id="heap-info模拟堆"><a href="#heap-info模拟堆" class="headerlink" title="heap-info模拟堆"></a>heap-info模拟堆</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="malloc-state，每次malloc的调用会根据该结构的实例来进行操作，取得一个chunk。"><a href="#malloc-state，每次malloc的调用会根据该结构的实例来进行操作，取得一个chunk。" class="headerlink" title="malloc_state，每次malloc的调用会根据该结构的实例来进行操作，取得一个chunk。"></a>malloc_state，每次malloc的调用会根据该结构的实例来进行操作，取得一个chunk。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);       <span class="comment">//串行分配分配区，上锁，多线程等待。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;                          <span class="comment">//bit0表示是否有fastbin，bit1表示是否能返回连续的虚拟地址空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];		<span class="comment">//Fastbins数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;						<span class="comment">//TopChunk指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;				<span class="comment">//last_remainder Chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above </span></span><br><span class="line"><span class="comment">  unsorted bin is bins[0]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    </span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>				<span class="comment">//指向下一个malloc_state</span></span><br><span class="line">    										<span class="comment">//在main_arena中，指向main_arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="main-arena。实际是malloc-state的一个静态实例。main-arena只有一个（主线程），多线程下根据需要可以创建none-main-arena，组成链表，且一旦创建就不能再销毁。"><a href="#main-arena。实际是malloc-state的一个静态实例。main-arena只有一个（主线程），多线程下根据需要可以创建none-main-arena，组成链表，且一旦创建就不能再销毁。" class="headerlink" title="main_arena。实际是malloc_state的一个静态实例。main_arena只有一个（主线程），多线程下根据需要可以创建none_main _arena，组成链表，且一旦创建就不能再销毁。"></a>main_arena。实际是malloc_state的一个静态实例。main_arena只有一个（主线程），多线程下根据需要可以创建none_main _arena，组成链表，且一旦创建就不能再销毁。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><h5 id="malloc-chunk，堆块的基本结构。"><a href="#malloc-chunk，堆块的基本结构。" class="headerlink" title="malloc_chunk，堆块的基本结构。"></a>malloc_chunk，堆块的基本结构。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="容器Bins"><a href="#容器Bins" class="headerlink" title="容器Bins"></a>容器Bins</h4><ul>
<li><h4 id="Fastbin相关（不同于别的bin是FIFO，该bin遵循LIFO原则）"><a href="#Fastbin相关（不同于别的bin是FIFO，该bin遵循LIFO原则）" class="headerlink" title="Fastbin相关（不同于别的bin是FIFO，该bin遵循LIFO原则）"></a>Fastbin相关（不同于别的bin是FIFO，该bin遵循LIFO原则）</h4><ul>
<li>在malloc_state里寻找idx处的fastbin。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>根据chunk的大小计算fastbin在fastbins数组中的下标，0, 1不存在，需减去2（例如，16B的fastbin的下标是16/8 - 2 = 0）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>fastbin的大小限制（32bits是0x50，64bit是160B)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="comment">//fastbins数组的最大下标=(88 / 8) - 2 + 1 = 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将malloc(size)的大小转为相应的malloc_chunk结构的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>
</li>
<li><p>fastbin虽然不会改变flag、从列表unlink之类的，但是在一定条件下也会触发合并。即当free的chunk和相邻的合并后大于FASTBIN_CONSOLIDATION_THRESHOLD(64k)时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="设置和获得fastbin-最大chunk的size。都是对全局变量global-max-fast操作。在利用时如果能改变这和值，就可以将fastbin-attack推广到更大的chunk。"><a href="#设置和获得fastbin-最大chunk的size。都是对全局变量global-max-fast操作。在利用时如果能改变这和值，就可以将fastbin-attack推广到更大的chunk。" class="headerlink" title="设置和获得fastbin 最大chunk的size。都是对全局变量global_max_fast操作。在利用时如果能改变这和值，就可以将fastbin attack推广到更大的chunk。"></a>设置和获得fastbin 最大chunk的size。都是对全局变量global_max_fast操作。在利用时如果能改变这和值，就可以将fastbin attack推广到更大的chunk。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \</span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)						      \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line">get_max_fast (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h5><ul>
<li><p>是“刚刚空闲出来的堆内存”与bins之间的缓存。是一个队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the "unsorted" bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h4><ul>
<li><h5 id="malloc-size-t-bytes"><a href="#malloc-size-t-bytes" class="headerlink" title="malloc(size_t bytes)"></a>malloc(size_t bytes)</h5><ul>
<li><p>实际实现是<strong>libc_malloc函数。当__</strong>malloc_hook值非null时，调用HOOK函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>有意思的是__malloc_hook地址的值的获取，用到了原子操作读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line">  (&#123; __typeof (x) __x; __asm (<span class="string">""</span> : <span class="string">"=r"</span> (__x) : <span class="string">"0"</span> (x)); __x; &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将请求的size转为相应的chunk大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">  &#123;</span><br><span class="line">    __set_errno (ENOMEM);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">//取得空闲分配区  </span></span><br><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line"><span class="comment">//分配内存</span></span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="comment">//无效，重新获得可用的分配区</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line"><span class="keyword">return</span> victim;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="Free函数"><a href="#Free函数" class="headerlink" title="Free函数"></a>Free函数</h5><ul>
<li><p>同样的内部有一个HOOK的包装，__free_hook不为0时，会替代free执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>free空指针是安全的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果chunk是mmap分配的，则mumap回收。并且根据策略动态调整 brk/mmap的阈值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line"> &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">      &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize (p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终调用_int_free实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar_ptr = arena_for_chunk (p);</span><br><span class="line">_int_free (ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在_int_free函数中，有很多check。</p>
<ul>
<li><p>chunk地址不会出现在地址空间的结束附近。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>chunk的size大小不小于MINSIZE，且内存对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查p的合法性、以及p的相邻chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_check_inuse_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);                           <span class="comment">//检查p的大小，地址空间是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));                               <span class="comment">//p必须是inuse的（通过下一个chunk的size字段判断）</span></span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);                            </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it's worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))                            <span class="comment">//p的前一个chunk空闲</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);              <span class="comment">//校验p前一个chunk的后一个chunk是p</span></span><br><span class="line">      do_check_free_chunk (av, prv);               <span class="comment">//释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)                            </span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));                <span class="comment">//top  的pre_size一直是1</span></span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))                       </span><br><span class="line">    do_check_free_chunk (av, next);              <span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在do_check_free_chunk下的check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">/* Chunk must claim to be free ... */</span></span><br><span class="line">assert (!inuse (p));</span><br><span class="line">assert (!chunk_is_mmapped (p));</span><br><span class="line">      </span><br><span class="line"><span class="comment">/* Unless a special marker, must have OK fields */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &gt;= MINSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">    assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* ... matching footer field */</span></span><br><span class="line">    <span class="comment">/*下个chunk的prev_size和当前chunk的size校验*/</span></span><br><span class="line">    assert (prev_size (next_chunk (p)) == sz);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* ... and is fully consolidated */</span></span><br><span class="line">    <span class="comment">/*确保相邻的chunk都已经合并*/</span></span><br><span class="line">    assert (prev_inuse (p));</span><br><span class="line">    assert (next == av-&gt;top || inuse (next));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* ... and has minimally sane links */</span></span><br><span class="line">    <span class="comment">/*fd、bk环校验*/</span></span><br><span class="line">    assert (p-&gt;fd-&gt;bk == p);</span><br><span class="line">    assert (p-&gt;bk-&gt;fd == p);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* markers are always of size SIZE_SZ */</span></span><br><span class="line">  assert (sz == SIZE_SZ);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对将释放的chunk的归类（哪一个bin）</p>
<ul>
<li><h6 id="属于fastbin，size满足小于get-max-fast-，且如果设置了TRIM-FASTBINS，该chunk不与top相邻。"><a href="#属于fastbin，size满足小于get-max-fast-，且如果设置了TRIM-FASTBINS，该chunk不与top相邻。" class="headerlink" title="属于fastbin，size满足小于get_max_fast()，且如果设置了TRIM_FASTBINS，该chunk不与top相邻。"></a>属于fastbin，size满足小于get_max_fast()，且如果设置了TRIM_FASTBINS，该chunk不与top相邻。</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don't place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>
</li>
<li><p>check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*检查next chunk的size合法*/</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">		  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)                                     </span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">		     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//chunk转为用户mem</span></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实际就是用null填充这段内存</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">free_perturb (<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入fastbin单向链表，两个检查，一个是不能连续free同一个chunk（构成double free）；另一个是插入的fastbin的chunk的大小要相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">   <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line">      </span><br><span class="line">     <span class="comment">/*当前fastbin的头一个chunk不能是这个，否则就是double free，其实有问题，只需要间隔一个还是会double free*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/*插入链表头部*/</span></span><br><span class="line">p-&gt;fd = old;</span><br><span class="line">*fb = p;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">      size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">      only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">      allocated again.  */</span></span><br><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">"invalid fastbin entry (free)"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* ###### 不属于fastbin时，检查的主要是，p不能是top chunk；p的next chunk不能超出当前arena的范围；nextchunk的prev_inuse无效；next chunk的size合理。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block. top chunk 不允许free的 */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     malloc_printerr (<span class="string">"double free or corruption (top)"</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  </span></span><br><span class="line"><span class="comment">     nextchunk 超出分配区的内存范围*/</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">		  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">		  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">"double free or corruption (out)"</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  </span></span><br><span class="line"><span class="comment">     该chunk已经是free'd，通过nextchunk的prev_inuse校验*/</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     malloc_printerr (<span class="string">"double free or corruption (!prev)"</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">/*nextchunk的size不合法*/</span></span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">"free(): invalid next size (normal)"</span>);</span><br><span class="line">   </span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>

* 同样要memset置null，然后与相邻的空闲chunk合并。如果不是和top chunk相邻，就会先放入usorted bin的头部。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward </span></span><br><span class="line"><span class="comment">   当前一个chunk空闲时，prev_size有效，可以用来访问前一个chunk</span></span><br><span class="line"><span class="comment">   并且与它的size相校验*/</span></span><br><span class="line">      </span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">     prevsize = prev_size (p);</span><br><span class="line">     size += prevsize;</span><br><span class="line">     p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))        </span><br><span class="line">       malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">     unlink_chunk (av, p);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">/*nextchunk 不是top时*/</span></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit </span></span><br><span class="line"><span class="comment">     取得下下个chunk的标志字段*/</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">/* consolidate forward </span></span><br><span class="line"><span class="comment">     nextchunk是空闲的，合并*/</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink_chunk (av, nextchunk);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span><span class="comment">/*否则只消除nextchunk的标志位，该chunk已经free'd*/</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment"> free'd的chunk首先会放进unsorted bin中，直到在malloc时遍历过一次</span></span><br><span class="line"><span class="comment"> 在unsroted bin的头部插入，双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      </span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">"free(): corrupted unsorted chunks"</span>);</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line">     <span class="comment">//bin的第一个chunk的prev_size置有效</span></span><br><span class="line">     <span class="comment">//chunk的下一个chunk的prev_size设为size</span></span><br><span class="line">     set_head(p, size | PREV_INUSE); </span><br><span class="line">     set_foot(p, size);</span><br><span class="line">     <span class="comment">//确保free'd</span></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

* 和top chunk相邻的直接并入top chunk；更新top

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">  与top chunk相邻时，直接合并，而不是放入unsorted bin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 触发top chunk收缩，和fastbins的处理malloc_consolidate；由于fastbin的标志位并不改变，我们不知道top附近有没有fastbin，但是作为一种妥协，glibc会在达到fastbin 合并阈值的时候，调用malloc_consolidate（mini的free，针对于fastbin）。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

* malloc_consolidate函数，类似于free，只是会处理所有的fastbin。并插入到unsorted bin中。

  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">unsorted_bin-&gt;fd = p;</span><br><span class="line">first_unsorted-&gt;bk = p;</span><br></pre></td></tr></table></figure>
</code></pre><p>* </p>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="../../../../tags/heap/">heap</a>
            
        </div>
        
    </article>
    
    <p>本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！</p>
    
    
</div>
<script src="../../../../js/busuanzi.pure.mini.js"></script>

        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about" title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help">急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        

    </div>
</footer>
<script src="../../../../js/InsightSearch.js"></script>
<script src="../../../../js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '11/22/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
